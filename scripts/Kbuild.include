# SPDX-License-Identifier: GPL-2.0
####
# kbuild: Generic definitions

# Convenient variables
comma   := ,
quote   := "
squote  := '
empty   :=
space   := $(empty) $(empty)
space_escape := _-_SPACE_-_
pound := \#
define newline


endef

###
# Comparison macros.
# Usage: $(call test-lt, $(CONFIG_LLD_VERSION), 150000)
#
# Use $(intcmp ...) if supported. (Make >= 4.4)
# Otherwise, fall back to the 'test' shell command.
ifeq ($(intcmp 1,0,,,y),y)
test-ge = $(intcmp $(strip $1)0, $(strip $2)0,,y,y)
test-gt = $(intcmp $(strip $1)0, $(strip $2)0,,,y)
else
test-ge = $(shell test $(strip $1)0 -ge $(strip $2)0 && echo y)
test-gt = $(shell test $(strip $1)0 -gt $(strip $2)0 && echo y)
endif
test-le = $(call test-ge, $2, $1)
test-lt = $(call test-gt, $2, $1)

###
# Name of target with a '.' as filename prefix. foo/bar.o => foo/.bar.o
dot-target = $(dir $@).$(notdir $@)

###
# Name of target with a '.tmp_' as filename prefix. foo/bar.o => foo/.tmp_bar.o
tmp-target = $(dir $@).tmp_$(notdir $@)

###
# The temporary file to save gcc -MMD generated dependencies must not
# contain a comma
depfile = $(subst $(comma),_,$(dot-target).d)

###
# filename of target with directory and extension stripped
basetarget = $(basename $(notdir $@))

###
# real prerequisites without phony targets
# NOTE-XY: current file is included by other Makefiles, and the variable `PHONY` is defined in other Makefiles.
# > for example: [include this file by main Makefile](https://github.com/catitw/linux/blob/388ea649191806fca42fb2deaa7c91349175335f/Makefile#L425-)
real-prereqs = $(filter-out $(PHONY), $^)

###
# Escape single quote for use in echo statements
escsq = $(subst $(squote),'\$(squote)',$1)

###
# Quote a string to pass it to C files. foo => '"foo"'
stringify = $(squote)$(quote)$1$(quote)$(squote)

###
# The path to Kbuild or Makefile. Kbuild has precedence over Makefile.
kbuild-file = $(or $(wildcard $(src)/Kbuild),$(src)/Makefile)

###
# Read a file, replacing newlines with spaces
#
# Make 4.2 or later can read a file by using its builtin function.
ifneq ($(filter-out 4.0 4.1, $(MAKE_VERSION)),)
read-file = $(subst $(newline),$(space),$(file < $1))
else
read-file = $(shell cat $1 2>/dev/null)
endif

###
# Easy method for doing a status message
       kecho := :
 quiet_kecho := echo
silent_kecho := :
# NOTE-XY: see [quiet variable setting](https://github.com/catitw/linux/blob/388ea649191806fca42fb2deaa7c91349175335f/Makefile#L110-L121)
# NOTE-XY: the `:` is no-op command in shell. see `$(kecho)` usage in following `filechk` define.
# > see [noop in bash](https://stackoverflow.com/questions/12404661/what-is-the-use-case-of-noop-in-bash)
kecho := $($(quiet)kecho)

###
# filechk is used to check if the content of a generated file is updated.
# Sample usage:
#
# filechk_sample = echo $(KERNELRELEASE)
# version.h: FORCE
#	$(call filechk,sample)
#
# The rule defined shall write to stdout the content of the new file.
# The existing file will be compared with the new one.
# - If no file exist it is created
# - If the content differ the new file is used
# - If they are equal no change, and no timestamp update
#
# NOTE-XY: 
# 1. generate the new temp file with the pre-defined filechk_$(1) rule.
# 2. overwrite the existing file with the new temp file if they are different.
define filechk
	$(check-FORCE)
	$(Q)set -e;						\
	mkdir -p $(dir $@);					\
	trap "rm -f $(tmp-target)" EXIT;			\
	{ $(filechk_$(1)); } > $(tmp-target);			\
	if [ ! -r $@ ] || ! cmp -s $@ $(tmp-target); then	\
		$(kecho) '  UPD     $@';			\
		mv -f $(tmp-target) $@;				\
	fi
endef

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir
# NOTE-XY: TODO: explore the file `Makefile.kbuild`.
build := -f $(srctree)/scripts/Makefile.build obj

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=
# Usage:
# $(Q)$(MAKE) $(clean)=dir
# NOTE-XY: TODO: explore the file `Makefile.clean`.
clean := -f $(srctree)/scripts/Makefile.clean obj

# pring log
#
# If quiet is "silent_", print nothing and sink stdout
# If quiet is "quiet_", print short log
# If quiet is empty, print short log and whole command
silent_log_print = exec >/dev/null;
 quiet_log_print = $(if $(quiet_cmd_$1), echo '  $(call escsq,$(quiet_cmd_$1)$(why))';)
       log_print = echo '$(pound) $(call escsq,$(or $(quiet_cmd_$1),cmd_$1 $@)$(why))'; \
                   echo '  $(call escsq,$(cmd_$1))';

# Delete the target on interruption
#
# GNU Make automatically deletes the target if it has already been changed by
# the interrupted recipe. So, you can safely stop the build by Ctrl-C (Make
# will delete incomplete targets), and resume it later.
#
# However, this does not work when the stderr is piped to another program, like
#  $ make >&2 | tee log
# Make dies with SIGPIPE before cleaning the targets.
#
# To address it, we clean the target in signal traps.
#
# Make deletes the target when it catches SIGHUP, SIGINT, SIGQUIT, SIGTERM.
# So, we cover them, and also SIGPIPE just in case.
#
# Of course, this is unneeded for phony targets.
# NOTE-XY: how it works:
# 1. remote the $@ file first.
# 2. reset the signal trap (`trap - $(sig)`)
# 3. resend the signal
delete-on-interrupt = \
	$(if $(filter-out $(PHONY), $@), \
		$(foreach sig, HUP INT QUIT TERM PIPE, \
			trap 'rm -f $@; trap - $(sig); kill -s $(sig) $$$$' $(sig);))

# print and execute commands
# NOTE-XY: how it works:
# - `;` separated commands in bash will be executed one by one in same shell process.
cmd = @$(if $(cmd_$(1)),set -e; $($(quiet)log_print) $(delete-on-interrupt) $(cmd_$(1)),:)

###
# if_changed      - execute command if any prerequisite is newer than
#                   target, or command line has changed
# if_changed_dep  - as if_changed, but uses fixdep to reveal dependencies
#                   including used config symbols
# if_changed_rule - as if_changed but execute rule instead
# See Documentation/kbuild/makefiles.rst for more info

ifneq ($(KBUILD_NOCMDDEP),1)
# Check if both commands are the same including their order. Result is empty
# string if equal. User may override this check using make KBUILD_NOCMDDEP=1
# If the target does not exist, the *.cmd file should not be included so
# $(savedcmd_$@) gets empty. Then, target will be built even if $(newer-prereqs)
# happens to become empty.
# NOTE-XY: we read back the variable `savedcmd_$@` stored in the `$(dot-target).cmd` file in `Makefile.build` file.
# the flow is:
# 1. we called the `build` variable defined previous, and it will lead us to sub-make the `Makefile.build` file.
# 2. in the `Makefile.build` file, we called `-include` to try to include the `$(dot-target).cmd` file if it existsï¼Œ
#    and we read back the variable `savedcmd_$@`.
cmd-check = $(filter-out $(subst $(space),$(space_escape),$(strip $(savedcmd_$@))), \
                         $(subst $(space),$(space_escape),$(strip $(cmd_$1))))
else
# We still need to detect missing targets.
cmd-check = $(if $(strip $(savedcmd_$@)),,1)
endif

# Replace >$< with >$$< to preserve $ when reloading the .cmd file
# (needed for make)
# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file
# (needed for make)
# Replace >'< with >'\''< to be able to enclose the whole string in '...'
# (needed for the shell)
make-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(cmd_$(1)))))

# Find any prerequisites that are newer than target or that do not exist.
# PHONY targets skipped in both cases.
# If there is no prerequisite other than phony targets, $(newer-prereqs) becomes
# empty even if the target does not exist. cmd-check saves this corner case.
# NOTE-XY:
# - `$?`: The names of all the prerequisites that are newer than the target,
#   or that do not exist.
# see [$?](https://www.gnu.org/software/make/manual/make.html#Include:~:text=%E9%9A%90%E5%BC%8F%E8%A7%84%E5%88%99%EF%BC%89%E3%80%82-,%24%3F,-The%20names%20of)
newer-prereqs = $(filter-out $(PHONY),$?)

# It is a typical mistake to forget the FORCE prerequisite. Check it here so
# no more breakage will slip in.
# NOTE-XY:
# `$(warning ...)` will be evaluated by makefile, and expression return empty string finally.
check-FORCE = $(if $(filter FORCE, $^),,$(warning FORCE prerequisite is missing))

# NOTE-XY: 
# - `$(newer-prereqs)`: check if any prerequisite is newer than target.
# - `$(cmd-check)`: check if command has changed.
# - `$(check-FORCE)`: check if `FORCE` is in prerequisites.
# the makefile expression `$(if-changed-cond)` will evaluate all `$(xxx)` it includes and return a string finally.
if-changed-cond = $(newer-prereqs)$(cmd-check)$(check-FORCE)

# Execute command if command has changed or prerequisite(s) are updated.
#
# NOTE-XY: `$(if-changed-cond)` will be evaluated to a string by makefile, and if the string is not empty,
# the `$(cmd_and_savecmd)` will be executed.
# > see [command-change-detection](https://docs.kernel.org/kbuild/makefiles.html#command-change-detection)
# 
# - Usage:
#   ```makefile
#   quiet_cmd_<command> = ...
#         cmd_<command> = ...
#
#   <target>: <source(s)> FORCE
#       $(call if_changed,<command>)
#   ```
if_changed = $(if $(if-changed-cond),$(cmd_and_savecmd),@:)

# NOTE-XY: we read back the variable `savedcmd_$@` stored in the `$(dot-target).cmd` file in `Makefile.build` file.
cmd_and_savecmd =                                                            \
	$(cmd);                                                              \
	printf '%s\n' 'savedcmd_$@ := $(make-cmd)' > $(dot-target).cmd

# Execute the command and also postprocess generated .d dependencies file.
if_changed_dep = $(if $(if-changed-cond),$(cmd_and_fixdep),@:)

# NOTE-XY:
# - `fixdep` script: 
#   - usage `fixdep <depfile> <target> '<command>'`.
#   - it will read the dependency file `<depfile>`, and write transformed dependency snipped to stdout.
#   > see more in `fixdep.c` comments.
# 
# - classic usage: 
#   ```makefile
#   $(host-cobjs): $(obj)/%.o: $(obj)/%.c FORCE
#	    $(call if_changed_dep,host-cobjs)
#   ```
#   this will generate file `scripts/kconfig/.conf.cmd` in the build directory.
#   > see the recipe defination in file `Makefile.host`. TODO: link.
cmd_and_fixdep =                                                             \
	$(cmd);                                                              \
	$(objtree)/scripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).cmd;\
	rm -f $(depfile)

# Usage: $(call if_changed_rule,foo)
# Will check if $(cmd_foo) or any of the prerequisites changed,
# and if so will execute $(rule_foo).
#
# NOTE-XY:
# rules are mainly defined in file `Makefile.build`. use cmd `rg --glob-case-insensitive -g '*makefile*' '\brule_\w+'` to found them.
# exmaple:
# ```makefile
#  define rule_rustc_o_rs
#  	$(call cmd_and_fixdep,rustc_o_rs)
#  	$(call cmd,gen_objtooldep)
#  endef
# ```
if_changed_rule = $(if $(if-changed-cond),$(rule_$(1)),@:)

###
# why - tell why a target got built
#       enabled by make V=2
#       Output (listed in the order they are checked):
#          (1) - due to target is PHONY
#          (2) - due to target missing
#          (3) - due to: file1.h file2.h
#          (4) - due to command line change
#          (5) - due to missing .cmd file
#          (6) - due to target not in $(targets)
# (1) PHONY targets are always build
# (2) No target, so we better build it
# (3) Prerequisite is newer than target
# (4) The command line stored in the file named dir/.target.cmd
#     differed from actual command line. This happens when compiler
#     options changes
# (5) No dir/.target.cmd file (used to store command line)
# (6) No dir/.target.cmd file and target not listed in $(targets)
#     This is a good hint that there is a bug in the kbuild file
ifneq ($(findstring 2, $(KBUILD_VERBOSE)),)
_why =                                                                        \
    $(if $(filter $@, $(PHONY)),- due to target is PHONY,                    \
        $(if $(wildcard $@),                                                 \
            $(if $(newer-prereqs),- due to: $(newer-prereqs),                \
                $(if $(cmd-check),                                           \
                    $(if $(savedcmd_$@),- due to command line change,        \
                        $(if $(filter $@, $(targets)),                       \
                            - due to missing .cmd file,                      \
                            - due to $(notdir $@) not in $$(targets)         \
                         )                                                   \
                     )                                                       \
                 )                                                           \
             ),                                                              \
             - due to target missing                                         \
         )                                                                   \
     )

why = $(space)$(strip $(_why))
endif

###############################################################################

# delete partially updated (i.e. corrupted) files on error
.DELETE_ON_ERROR:

# do not delete intermediate files automatically
#
# .NOTINTERMEDIATE is more correct, but only available on newer Make versions.
# Make 4.4 introduced .NOTINTERMEDIATE, and it appears in .FEATURES, but the
# global .NOTINTERMEDIATE does not work. We can use it on Make > 4.4.
# Use .SECONDARY for older Make versions, but "newer-prereq" cannot detect
# deleted files.
ifneq ($(and $(filter notintermediate, $(.FEATURES)),$(filter-out 4.4,$(MAKE_VERSION))),)
.NOTINTERMEDIATE:
else
.SECONDARY:
endif
